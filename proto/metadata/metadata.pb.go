// Code generated by protoc-gen-go.
// source: metadata.proto
// DO NOT EDIT!

/*
Package metadata is a generated protocol buffer package.

It is generated from these files:
	metadata.proto

It has these top-level messages:
	Void
	RmReq
	MvReq
	HomeReq
	CpReq
	MkdirReq
	StatReq
	Metadata
*/
package metadata

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Void struct {
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}

type RmReq struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token" json:"access_token,omitempty"`
	Path        string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *RmReq) Reset()         { *m = RmReq{} }
func (m *RmReq) String() string { return proto.CompactTextString(m) }
func (*RmReq) ProtoMessage()    {}

type MvReq struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token" json:"access_token,omitempty"`
	Src         string `protobuf:"bytes,2,opt,name=src" json:"src,omitempty"`
	Dst         string `protobuf:"bytes,3,opt,name=dst" json:"dst,omitempty"`
}

func (m *MvReq) Reset()         { *m = MvReq{} }
func (m *MvReq) String() string { return proto.CompactTextString(m) }
func (*MvReq) ProtoMessage()    {}

type HomeReq struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token" json:"access_token,omitempty"`
}

func (m *HomeReq) Reset()         { *m = HomeReq{} }
func (m *HomeReq) String() string { return proto.CompactTextString(m) }
func (*HomeReq) ProtoMessage()    {}

type CpReq struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token" json:"access_token,omitempty"`
	Src         string `protobuf:"bytes,2,opt,name=src" json:"src,omitempty"`
	Dst         string `protobuf:"bytes,3,opt,name=dst" json:"dst,omitempty"`
}

func (m *CpReq) Reset()         { *m = CpReq{} }
func (m *CpReq) String() string { return proto.CompactTextString(m) }
func (*CpReq) ProtoMessage()    {}

type MkdirReq struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token" json:"access_token,omitempty"`
	Path        string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *MkdirReq) Reset()         { *m = MkdirReq{} }
func (m *MkdirReq) String() string { return proto.CompactTextString(m) }
func (*MkdirReq) ProtoMessage()    {}

type StatReq struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token" json:"access_token,omitempty"`
	Path        string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Children    bool   `protobuf:"varint,3,opt,name=children" json:"children,omitempty"`
}

func (m *StatReq) Reset()         { *m = StatReq{} }
func (m *StatReq) String() string { return proto.CompactTextString(m) }
func (*StatReq) ProtoMessage()    {}

type Metadata struct {
	Id          string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Path        string      `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Size        uint32      `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	IsContainer bool        `protobuf:"varint,4,opt,name=is_container" json:"is_container,omitempty"`
	MimeType    string      `protobuf:"bytes,5,opt,name=mime_type" json:"mime_type,omitempty"`
	Checksum    string      `protobuf:"bytes,6,opt,name=checksum" json:"checksum,omitempty"`
	Modified    uint32      `protobuf:"varint,7,opt,name=modified" json:"modified,omitempty"`
	Etag        string      `protobuf:"bytes,8,opt,name=etag" json:"etag,omitempty"`
	Permissions uint32      `protobuf:"varint,9,opt,name=permissions" json:"permissions,omitempty"`
	Children    []*Metadata `protobuf:"bytes,10,rep,name=children" json:"children,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}

func (m *Metadata) GetChildren() []*Metadata {
	if m != nil {
		return m.Children
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Meta service

type MetaClient interface {
	Home(ctx context.Context, in *HomeReq, opts ...grpc.CallOption) (*Void, error)
	Mkdir(ctx context.Context, in *MkdirReq, opts ...grpc.CallOption) (*Void, error)
	Stat(ctx context.Context, in *StatReq, opts ...grpc.CallOption) (*Metadata, error)
	Cp(ctx context.Context, in *CpReq, opts ...grpc.CallOption) (*Void, error)
	Mv(ctx context.Context, in *MvReq, opts ...grpc.CallOption) (*Void, error)
	Rm(ctx context.Context, in *RmReq, opts ...grpc.CallOption) (*Void, error)
}

type metaClient struct {
	cc *grpc.ClientConn
}

func NewMetaClient(cc *grpc.ClientConn) MetaClient {
	return &metaClient{cc}
}

func (c *metaClient) Home(ctx context.Context, in *HomeReq, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/metadata.Meta/Home", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Mkdir(ctx context.Context, in *MkdirReq, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/metadata.Meta/Mkdir", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Stat(ctx context.Context, in *StatReq, opts ...grpc.CallOption) (*Metadata, error) {
	out := new(Metadata)
	err := grpc.Invoke(ctx, "/metadata.Meta/Stat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Cp(ctx context.Context, in *CpReq, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/metadata.Meta/Cp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Mv(ctx context.Context, in *MvReq, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/metadata.Meta/Mv", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Rm(ctx context.Context, in *RmReq, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/metadata.Meta/Rm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Meta service

type MetaServer interface {
	Home(context.Context, *HomeReq) (*Void, error)
	Mkdir(context.Context, *MkdirReq) (*Void, error)
	Stat(context.Context, *StatReq) (*Metadata, error)
	Cp(context.Context, *CpReq) (*Void, error)
	Mv(context.Context, *MvReq) (*Void, error)
	Rm(context.Context, *RmReq) (*Void, error)
}

func RegisterMetaServer(s *grpc.Server, srv MetaServer) {
	s.RegisterService(&_Meta_serviceDesc, srv)
}

func _Meta_Home_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(HomeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Home(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Mkdir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MkdirReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Mkdir(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StatReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Stat(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Cp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Cp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Mv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MvReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Mv(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Rm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RmReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Rm(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Meta_serviceDesc = grpc.ServiceDesc{
	ServiceName: "metadata.Meta",
	HandlerType: (*MetaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Home",
			Handler:    _Meta_Home_Handler,
		},
		{
			MethodName: "Mkdir",
			Handler:    _Meta_Mkdir_Handler,
		},
		{
			MethodName: "Stat",
			Handler:    _Meta_Stat_Handler,
		},
		{
			MethodName: "Cp",
			Handler:    _Meta_Cp_Handler,
		},
		{
			MethodName: "Mv",
			Handler:    _Meta_Mv_Handler,
		},
		{
			MethodName: "Rm",
			Handler:    _Meta_Rm_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
